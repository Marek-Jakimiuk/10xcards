# REST API Plan

## 1. Resources

1. **Users**
   - Database Table: `users`
   - Key Fields: `id`, `email`, `created_at`, `role`
   - Note: Managed by Supabase Auth and enforced via RLS.

2. **Decks**
   - Database Table: `decks`
   - Key Fields: `id`, `user_id`, `name`, `description`, `created_at`, `updated_at`
   - Relationship: Each deck belongs to a user.

3. **Flashcards**
   - Database Table: `fiszki`
   - Key Fields: `id`, `user_id`, `deck_id`, `przod` (front), `tyl` (back), `status` (allowed values: 'zatwierdzona', 'odrzucona', 'oczekująca'), `metadane`, `created_at`, `updated_at`
   - Relationship: Belongs to a user and may be associated with a deck.

4. **Flashcards History & Logs** (Internal Usage)
   - Tables: `fiszki_history` and `fiszki_logs`
   - Purpose: Version tracking and logging actions on flashcards. Typically not exposed directly via public API.

---

## 2. Endpoints

### B. Flashcards Endpoints

1. **List Flashcards**
   - **Method:** GET
   - **URL:** `/api/flashcards`
   - **Description:** Retrieves a paginated list of flashcards for the authenticated user. Supports filtering by deck and status.
   - **Query Parameters:**
     - `page` (optional, default: 1)
     - `limit` (optional, default: 20)
     - `deckId` (optional): Filter by deck
     - `status` (optional): Filter by flashcard status
   - **Response:**
     ```json
     {
       "flashcards": [ { "id": "...", "przod": "...", "tyl": "...", "status": "..." } ],
       "pagination": { "page": 1, "limit": 20, "total": 100 }
     }
     ```

2. **Retrieve a Single Flashcard**
   - **Method:** GET
   - **URL:** `/api/flashcards/{id}`
   - **Description:** Retrieves details of a specific flashcard.
   - **Response:**
     ```json
     { "id": "...", "przod": "...", "tyl": "...", "status": "...", "deck_id": "..." }
     ```
3. **Create Flashcards**
   - **Method:** POST
   - **URL:** `/api/flashcards`
   - **Description:** Creates one or more flashcard entries. Used for both manual flashcard creation and AI-generated flashcards.
   - **Request Payload:**
     ```json
     {
       "deck_id": "optional-deck-id",
       "flashcards": [
         {
           "przod": "Front of the flashcard (max 200 chars)",
           "tyl": "Back of the flashcard (max 500 chars)",
           "status": "oczekująca" // default status for manually created flashcards
         },
         {
           "przod": "Another front",
           "tyl": "Another back",
           "status": "zatwierdzona" // can be used for AI-generated and approved cards
         }
       ]
     }
     ```
   - **Response:**
     - **Success (201):** Array of newly created flashcard objects.
     - **Error (400):** If validation fails:
       ```json
       {
         "error": "Validation Error",
         "details": [
           {
             "field": "przod",
             "message": "Front text exceeds maximum length of 200 characters"
           },
           {
             "field": "tyl", 
             "message": "Back text exceeds maximum length of 500 characters"
           }
         ]
       }
       ```
     - **Error (400):** If validation fails:
       ```json
       {
         "error": "Validation Error",
         "details": [
           {
             "field": "przod",
             "message": "Front text exceeds maximum length of 200 characters"
           },
           {
             "field": "tyl", 
             "message": "Back text exceeds maximum length of 500 characters"
           }
         ]
       }
       ```

4. **Update a Flashcard**
   - **Method:** PUT
   - **URL:** `/api/flashcards/{id}`
   - **Description:** Updates an existing flashcard. Allows editing of text and status.
   - **Request Payload:**
     ```json
     {
       "przod": "Updated front text",
       "tyl": "Updated back text",
       "status": "zatwierdzona" // or one of the allowed statuses
     }
     ```
   - **Response:**
     - **Success (200):** Updated flashcard details.
     - **Error (400):** If validations fail (e.g., exceeding character limits or invalid status).

5. **Delete a Flashcard**
   - **Method:** DELETE
   - **URL:** `/api/flashcards/{id}`
   - **Description:** Deletes a flashcard. Requires confirmation by the front end before deletion.
   - **Response:**
     - **Success (200):** Confirmation message.
     - **Error (404):** If the flashcard is not found.

6. **Generate Flashcards via AI**
   - **Method:** POST
   - **URL:** `/api/flashcards/generate`
   - **Description:** Accepts a block of text (between 1000 and 10000 characters) and returns a list of flashcard suggestions generated by an LLM via an external API.
   - **Request Payload:**
     ```json
     {
       "text": "Paste your text here..."
     }
     ```
   - **Response:**
     ```json
     {
       "suggestions": [
         { "przod": "Question 1?", "tyl": "Answer 1." },
         { "przod": "Question 2?", "tyl": "Answer 2." }
       ]
     }
     ```
   - **Note:** Must validate that the text length is within allowed limits. On acceptance of suggestions, a separate update (or create) endpoint will update the flashcard status to 'zatwierdzona'.

---

### C. Decks Endpoints

1. **List Decks**
   - **Method:** GET
   - **URL:** `/api/decks`
   - **Description:** Retrieves a list of all decks for the authenticated user.
   - **Response:**
     ```json
     {
       "decks": [ { "id": "...", "name": "Deck Name", "description": "Optional description" } ]
     }
     ```

2. **Create a New Deck**
   - **Method:** POST
   - **URL:** `/api/decks`
   - **Description:** Creates a new deck for organizing flashcards.
   - **Request Payload:**
     ```json
     {
       "name": "New Deck",
       "description": "Description for the deck"
     }
     ```
   - **Response:**
     - **Success (201):** Newly created deck details.

3. **Retrieve a Deck**
   - **Method:** GET
   - **URL:** `/api/decks/{id}`
   - **Description:** Retrieves details of a specific deck, including associated flashcards if needed.

4. **Update a Deck**
   - **Method:** PUT
   - **URL:** `/api/decks/{id}`
   - **Description:** Updates deck information.
   - **Request Payload:**
     ```json
     {
       "name": "Updated Deck Name",
       "description": "Updated description"
     }
     ```
   - **Response:**
     - **Success (200):** Updated deck details.

5. **Delete a Deck**
   - **Method:** DELETE
   - **URL:** `/api/decks/{id}`
   - **Description:** Deletes a deck. If flashcards are linked, they should either be reassigned or set to null (as per DB schema).
   - **Response:**
     - **Success (200):** Confirmation of deletion.

---

### D. Study Session Endpoint

1. **Start a Study Session**
   - **Method:** GET
   - **URL:** `/api/study-session`
   - **Description:** Retrieves a set of flashcards for a study session based on spaced repetition algorithms. The selection may be based on criteria such as user performance and scheduled review times.
   - **Query Parameters (optional):**
     - `deckId`: To filter flashcards by a specific deck
   - **Response:**
     ```json
     {
       "session": [ { "id": "...", "przod": "Question?", "tyl": "Answer." } ],
       "session_info": { "total": 10, "current_index": 0 }
     }
     ```

---

## 3. Authentication and Authorization

- **Mechanism:** All endpoints (except `/api/auth/register` and `/api/auth/login`) require authentication using JWT tokens issued by Supabase Auth.
- **Implementation:** Clients must include an Authorization header in the format: `Authorization: Bearer <token>`.
- **RLS Enforcement:** The Supabase database enforces Row Level Security (RLS) ensuring that users can only access their own data.

---

## 4. Validation and Business Logic

1. **Input Validation:**
   - Ensure that flashcard fields meet length requirements (e.g., `przod` <= 200 chars, `tyl` <= 500 chars).
   - For flashcard generation, validate that the submitted text is between 1000 and 10000 characters.
   - Verify allowed status values: only 'zatwierdzona', 'odrzucona', or 'oczekująca'.

2. **Business Logic Mapping:**
   - **Registration/Login:** Use standard authentication flows backed by Supabase Auth.
   - **Flashcard Generation:** On receiving text input, server-side logic calls an external LLM API (e.g., via Openrouter.ai) to generate flashcard suggestions. These suggestions are returned as a list, and upon user approval, the flashcards are created/updated with status 'zatwierdzona'.
   - **Editing and Approval:** Separate endpoints exist to update flashcards, allowing users to correct or approve AI-generated content.
   - **Study Session:** Use algorithms for spaced repetition to select flashcards based on user performance. The endpoint provides the required flashcards along with session metadata.

3. **Error Handling and Status Codes:**
   - **200 OK / 201 Created:** For successful operations.
   - **400 Bad Request:** For validation errors or malformed requests.
   - **401 Unauthorized:** When authentication fails or is missing.
   - **404 Not Found:** When requested resources do not exist.
   - **500 Internal Server Error:** For unexpected failures.

4. **Performance and Security Considerations:**
   - **Pagination, Filtering, and Sorting:** Implemented on GET list endpoints to efficiently navigate large datasets.
   - **Rate Limiting:** Consider applying rate limits on endpoints, especially on flashcard generation to prevent abuse.
   - **Data Security:** All sensitive operations require authentication and the backend should ensure that RLS policies are in place at the database level.

---

*Assumptions:*
- The external AI service for flashcard generation is reliable and its API response is normalized to our flashcard schema.
- Flashcard histories and logs are maintained internally for versioning and auditing rather than exposed to the end user.
- Study session endpoint encapsulates logic for spaced repetition without requiring the client to manage flashcard queueing.

This API plan aligns with the product requirements (PRD), the database schema, and the specified tech stack, offering a robust and scalable design for the 10x-cards application.
